mod components;
mod plugin;
mod systems;

pub use components::{Gif, GifAsset, GifPlayer};
pub use plugin::GifPlugin;
pub use systems::{animate_gifs, initialize_gifs};

/// This was generated by Github Copilot with GPT-5 mini model.
/// I resorted to using AI for tests because I was struggling myself,
/// and it is supposedly good at tests.
/// Critical analysis:
#[cfg(test)]
mod tests {
    use std::time::Duration;

    use crate::{
        gif::{animate_gifs, components::GifLoader, initialize_gifs},
        prelude::*,
    };
    use bevy::prelude::*;

    /// Build a minimal app for testing purposes
    fn build_app() -> App {
        // Build a minimal app with asset support and our systems
        let mut app = App::new();
        app.add_plugins(MinimalPlugins)
            .add_plugins(bevy::asset::AssetPlugin::default());

        // Ensure Image and GifAsset storage exist and the gif loader is registered
        app.init_asset::<Image>();
        app.init_asset::<GifAsset>();
        app.init_asset_loader::<GifLoader>();
        app
    }

    /// Update the app a few times until the [GifAsset] is properly loaded by the [AssetServer],
    /// or panic!
    fn wait_for_asset(app: &mut App, handle: &Handle<GifAsset>) {
        const MAX_TRIES: usize = 10;
        let mut tries = 0;
        loop {
            app.update();
            if let Some(gif_asset) = app.world().resource::<Assets<GifAsset>>().get(handle) {
                if !gif_asset.frames.is_empty() {
                    break;
                }
            }
            tries += 1;
            if tries > MAX_TRIES {
                panic!("GifAsset frames not populated after {} updates", MAX_TRIES);
            }
        }
    }

    #[test]
    fn test_gif_init() {
        let mut app = build_app();

        // Add the system under test
        app.add_systems(Update, initialize_gifs);

        // Load the gif asset via the AssetServer so the loader creates a GifAsset
        let handle: Handle<GifAsset> = app.world().load_asset("frog_five.gif");

        // Wait until frames vector is non-empty (loader parsed frames)
        wait_for_asset(&mut app, &handle);

        let entity = app
            .world_mut()
            .spawn((
                Sprite::default(),
                Gif {
                    handle: handle.clone(),
                },
            ))
            .id();

        // Run one update to let initialize_gifs run (it matches Added<Gif>)
        app.update();

        // Retrieve the GifAsset and check it was initialized (handles created)
        let assets = app.world().resource::<Assets<GifAsset>>();
        let gif_asset = assets.get(&handle).expect("GifAsset should be present");
        assert!(
            !gif_asset.handles.is_empty(),
            "initialize_gifs should have added Image handles"
        );
        assert_eq!(
            gif_asset.handles.len(),
            gif_asset.frames.len(),
            "one Image handle per frame expected"
        );

        // Check the spawned entity's Sprite and GifPlayer were initialized
        let world = app.world();
        let sprite = world
            .get::<Sprite>(entity)
            .expect("Sprite component should exist");
        let player = world
            .get::<GifPlayer>(entity)
            .expect("GifPlayer component should exist");

        // The sprite.image should be the first frame handle created by initialize_gifs
        let first_handle = gif_asset.handles.first().unwrap();
        assert_eq!(&sprite.image, first_handle);

        // player should have been initialized to first frame and have timer duration matching first frame
        let first_frame = &gif_asset.frames[0];
        assert_eq!(player.current, 0);
        assert_eq!(player.timer.duration(), first_frame.duration);
        assert_eq!(player.remaining, gif_asset.times);
    }

    #[test]
    fn test_custom_params_spawn() {
        let mut app = build_app();
        app.add_systems(Update, initialize_gifs);

        let handle: Handle<GifAsset> = app.world().load_asset("frog_five.gif");
        wait_for_asset(&mut app, &handle);

        // spawn sprite with custom properties AFTER frames are available
        let custom_size = Vec2::new(42.0, 24.0);
        let sprite = Sprite {
            image: Handle::<Image>::default(),
            flip_x: true,
            custom_size: Some(custom_size),
            ..Default::default()
        };

        let entity = app
            .world_mut()
            .spawn((
                sprite,
                Gif {
                    handle: handle.clone(),
                },
            ))
            .id();

        // let initialize_gifs run for the Added<Gif> entity
        app.update();

        let assets = app.world().resource::<Assets<GifAsset>>();
        let gif_asset = assets.get(&handle).expect("GifAsset should be present");
        assert!(
            !gif_asset.handles.is_empty(),
            "initialize_gifs should create Image handles"
        );

        let first_handle = gif_asset.handles.first().unwrap();

        let world = app.world();
        let sprite_after = world
            .get::<Sprite>(entity)
            .expect("Sprite component should exist");

        // sprite image must be set to first frame handle
        assert_eq!(&sprite_after.image, first_handle);

        // previously set properties must be preserved
        assert!(
            sprite_after.flip_x,
            "flip_x should be preserved by initialize_gifs"
        );
        assert_eq!(
            sprite_after.custom_size,
            Some(custom_size),
            "custom_size should be preserved"
        );
    }

    #[test]
    fn test_sprite_change_on_timer_tick() {
        let mut app = build_app();
        app.add_systems(Update, initialize_gifs);
        app.add_systems(Update, animate_gifs);

        let handle: Handle<GifAsset> = app.world().load_asset("frog_five.gif");
        wait_for_asset(&mut app, &handle);

        // ensure we have at least two frames to observe a change
        let gif_asset = app
            .world()
            .resource::<Assets<GifAsset>>()
            .get(&handle)
            .expect("GifAsset present after parsing");
        assert!(
            gif_asset.frames.len() >= 2,
            "test requires at least 2 frames in the GIF"
        );

        // spawn entity AFTER frames are available so initialize_gifs (Added<Gif>) runs when frames exist
        let entity = app
            .world_mut()
            .spawn(Gif {
                handle: handle.clone(),
            })
            .id();

        // let initialize_gifs set up handles and sprite.image
        app.update();

        // reborrow gif_asset and first frame duration
        let gif_asset = app
            .world()
            .resource::<Assets<GifAsset>>()
            .get(&handle)
            .expect("GifAsset present after init");
        assert!(
            gif_asset.handles.len() >= 2,
            "expect at least two image handles"
        );
        let first_frame_duration = gif_asset.frames[0].duration;

        // tick the GifPlayer(s) directly so the timer is considered finished
        // (avoids relying on Test Time being overwritten by the runner)
        {
            let mut query: QueryState<&mut GifPlayer> = app.world_mut().query::<&mut GifPlayer>();
            for mut player in query.iter_mut(app.world_mut()) {
                // advance by slightly less than the frame duration, so it finishes at the next update
                player
                    .timer
                    .tick(first_frame_duration - Duration::from_nanos(1));
                assert!(!player.timer.finished());
            }
        }

        // run systems (animate_gifs) which will see the timer finished and advance the sprite
        app.update();

        // assert sprite.image switched to the next handle
        let gif_asset = app
            .world()
            .resource::<Assets<GifAsset>>()
            .get(&handle)
            .expect("GifAsset should still be present");
        let handles = &gif_asset.handles;

        let sprite_after = app
            .world()
            .get::<Sprite>(entity)
            .expect("Sprite component should exist");

        // expect sprite.image to be the second handle after the tick
        assert_eq!(&sprite_after.image, &handles[1]);
    }

    #[test]
    fn test_nth_loading_and_updating() {
        let mut app = build_app();
        app.add_systems(Update, initialize_gifs);
        app.add_systems(Update, animate_gifs);

        let handle: Handle<GifAsset> = app.world().load_asset("frog_five.gif");
        wait_for_asset(&mut app, &handle);

        // ensure we have at least two frames to observe a change
        let gif_asset = app
            .world()
            .resource::<Assets<GifAsset>>()
            .get(&handle)
            .expect("GifAsset present after parsing");
        assert!(
            gif_asset.frames.len() >= 2,
            "test requires at least 2 frames in the GIF"
        );

        // spawn entity AFTER frames are available so initialize_gifs (Added<Gif>) runs when frames exist
        let _entity = app
            .world_mut()
            .spawn(Gif {
                handle: handle.clone(),
            })
            .id();

        // let initialize_gifs set up handles and sprite.image
        app.update();

        // check initial state
        {
            let assets = app.world().resource::<Assets<GifAsset>>();
            let gif_asset = assets.get(&handle).unwrap();

            assert_eq!(gif_asset.times, Some(4)); // 5 global loops minus 1

            let mut query = app.world_mut().query::<&GifPlayer>();
            let player = query
                .single(app.world())
                .expect("Should be exactly one player");
            assert_eq!(player.remaining, Some(4)); // Same than the GifAsset
        }

        // simulate a full gif rotation
        {
            let mut query = app.world_mut().query::<&mut GifPlayer>();
            for time in [1000, 200, 200, 200].iter() {
                // that's the duration of each frame of the frog gif
                let mut player = query
                    .single_mut(app.world_mut())
                    .expect("Should be exactly one player");
                player
                    .timer
                    .tick(Duration::from_millis(*time) - Duration::from_nanos(1));
                app.update();
            }
        }

        {
            let mut query = app.world_mut().query::<&GifPlayer>();
            let player = query
                .single(app.world_mut())
                .expect("Should be exactly one player");
            assert_eq!(player.remaining, Some(3)); // It decreases because time passed and one cycle concluded
            assert_eq!(player.current, 0); // looped over
        }
    }

    #[test]
    fn test_nth_stop_playing() {
        let mut app = build_app();
        app.add_systems(Update, initialize_gifs);
        app.add_systems(Update, animate_gifs);

        let handle: Handle<GifAsset> = app.world().load_asset("frog_once.gif");
        wait_for_asset(&mut app, &handle);

        // ensure we have at least two frames to observe a change
        let _gif_asset = app
            .world()
            .resource::<Assets<GifAsset>>()
            .get(&handle)
            .expect("GifAsset present after parsing");

        // spawn entity AFTER frames are available so initialize_gifs (Added<Gif>) runs when frames exist
        let _entity = app
            .world_mut()
            .spawn(Gif {
                handle: handle.clone(),
            })
            .id();

        // let initialize_gifs set up handles and sprite.image
        app.update();

        // simulate a full gif rotation, and beyond to trigger a potential new cycle
        {
            let mut query = app.world_mut().query::<&mut GifPlayer>();
            for time in [1000, 200, 200, 200, 1000].iter() {
                // that's the duration of each frame of the frog gif
                let mut player = query
                    .single_mut(app.world_mut())
                    .expect("Should be exactly one player");
                player
                    .timer
                    .tick(Duration::from_millis(*time) - Duration::from_nanos(1));
                app.update();
            }
        }

        {
            let mut query = app.world_mut().query::<&GifPlayer>();
            let player = query
                .single(app.world_mut())
                .expect("Should be exactly one player");
            assert_eq!(player.current, 0); // run only once so it stays at zero
            assert!(player.timer.paused());
        }
    }

    #[test]
    fn test_repeating_never_stops() {
        let mut app = build_app();
        app.add_systems(Update, initialize_gifs);
        app.add_systems(Update, animate_gifs);

        let handle: Handle<GifAsset> = app.world().load_asset("frog_infinite.gif");
        wait_for_asset(&mut app, &handle);

        // ensure we have at least two frames to observe a change
        let _gif_asset = app
            .world()
            .resource::<Assets<GifAsset>>()
            .get(&handle)
            .expect("GifAsset present after parsing");

        // spawn entity AFTER frames are available so initialize_gifs (Added<Gif>) runs when frames exist
        let _entity = app
            .world_mut()
            .spawn(Gif {
                handle: handle.clone(),
            })
            .id();

        // let initialize_gifs set up handles and sprite.image
        app.update();

        {
            // simulate a 5 and a half rotations
            let mut query = app.world_mut().query::<&mut GifPlayer>();
            for _ in 0..5 {
                for time in [1000, 200, 200, 200].iter() {
                    // that's the duration of each frame of the frog gif
                    let mut player = query
                        .single_mut(app.world_mut())
                        .expect("Should be exactly one player");
                    player
                        .timer
                        .tick(Duration::from_millis(*time) - Duration::from_nanos(1));
                    app.update();
                }
            }
            for time in [1000, 200, 200].iter() {
                // that's the duration of each frame of the frog gif
                let mut player = query
                    .single_mut(app.world_mut())
                    .expect("Should be exactly one player");
                player
                    .timer
                    .tick(Duration::from_millis(*time) - Duration::from_nanos(1));
                app.update();
            }
        }

        {
            let mut query = app.world_mut().query::<&GifPlayer>();
            let player = query
                .single(app.world_mut())
                .expect("Should be exactly one player");
            assert_eq!(player.remaining, None);
            assert!(!player.timer.paused());
            assert_eq!(player.current, 3);
        }
    }
}
